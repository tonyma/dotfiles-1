" Setup encodings {{{
set encoding=utf-8
scriptencoding utf-8
" }}}

" Load current directory as plugin if .development.vim exists. {{{

if len(findfile('.development.vim', getcwd())) > 0
  execute 'set runtimepath+=' . getcwd()
  for g:plug in split(glob(getcwd() . '/*'), '\n')
    execute 'set runtimepath+=' . g:plug
  endfor
  echom 'loading local plugin'
endif
let $PATH = '~/.pyenv/shims:'.$PATH
" }}}

" Setup XDG Home directory paths. {{{
let g:xdg_config_home=$XDG_CONFIG_HOME
if g:xdg_config_home ==# ''
  let g:xdg_config_home = $HOME.'/.config'
endif

let g:xdg_data_home=$XDG_DATA_HOME
if g:xdg_data_home ==# ''
  let g:xdg_data_home = $HOME.'/.local/share'
endif

let s:cachedir=$XDG_CACHE_HOME
if s:cachedir ==# ''
  let s:cachedir = $HOME.'/.cache'
endif

let &directory = s:cachedir.'/vim/swap'
if !isdirectory(&directory)
  call mkdir(&directory, 'p')
endif
let &backupdir = s:cachedir.'/vim/backup'
if !isdirectory(&backupdir)
  call mkdir(&backupdir, 'p')
endif
" }}}

" Setup Keymaps (for regular functions) {{{
" Delete search highlight
nnoremap <ESC><ESC> :<C-u>nohl<CR><ESC>

" Quickfix
nnoremap <C-x>q :<C-u>copen<CR><ESC>

nnoremap Q <Nop>
nnoremap <C-x> <Nop>
augroup TermSwitch
  " ターミナルで <C-\><C-n> による job <- -> normal モードの往復を可能にする
  silent! autocmd! TerminalOpen * nnoremap <buffer> <C-\><C-n> i
augroup END
augroup TermNoNumber
  silent! autocmd! TerminalOpen * setlocal nonumber
augroup END

nnoremap tc :<C-u>tabnew<CR><ESC>
nnoremap tp :<C-u>tabprevious<CR><ESC>
nnoremap tn :<C-u>tabnext<CR><ESC>
nnoremap tt :<C-u>term ++curwin<CR>
nnoremap tx :<C-u>term<CR>
nnoremap tv :<C-u>vnew \| :term ++curwin<CR>
" }}}

" Set MacVim options {{{
set guifont=MyricaM\ M\ for\ Powerline:h14
set linespace=3
set titlestring=vim\(%{substitute(getcwd(),\ $HOME,\ '~',\ '')}\)
" }}}

" Pyenv {{{
" PATHの自動更新関数
" | 指定された path が $PATH に存在せず、ディレクトリとして存在している場合
" | のみ $PATH に加える
let $PYTHON_CONFIGURE_OPTS="--enable-framework"
let $PYENV_DEFAULT_PACKAGES=$XDG_CONFIG_HOME."/pyenv/default-packages"
let $PYENV_ROOT=$HOME."/.pyenv"
let $PATH=$PYENV_ROOT."/bin:".$PATH

function! IncludePath(path)
  " define delimiter depends on platform
  if has('win16') || has('win32') || has('win64')
    let delimiter = ";"
  else
    let delimiter = ":"
  endif
  let pathlist = split($PATH, delimiter)
  if isdirectory(a:path) && index(pathlist, a:path) == -1
    let $PATH=a:path.delimiter.$PATH
  endif
endfunction

" ~/.pyenv/shims を $PATH に追加する
" これを行わないとpythonが正しく検索されない
call IncludePath(expand($PYENV_ROOT."/shims"))
" }}}

" Function: Edit Configurations {{{
let g:config_home = g:xdg_config_home . '/vim'
function! Config(bang)
  execute 'edit'.a:bang g:config_home.'/vimrc'
endfunction
command! -bang -nargs=0 Config :call Config('<bang>')

if !exists("*ConfigReload")
  function! ConfigReload()
    " reload vimrc
    execute 'source $MYVIMRC'
  endfunction
endif
command! -nargs=0 ConfigReload :call ConfigReload()
command! -nargs=0 ReloadConfig :call ConfigReload()
command! -nargs=0 Reload :call ConfigReload()
" }}}

" Function: Go Stringer {{{
function! GoStringer(count, line1, line2)
  if a:line2 == 0
    " 0レンジ指定
    return
  endif

  if a:count
    " 範囲指定がある
    let l:first_line = max([a:line1, 1])
    let l:last_line = max([a:line2, 1])
  else
    " 範囲指定がないので現在行を対象とする
    let l:first_line = a:line1
    let l:last_line = a:line1
  endif

  let l:type_name = s:capitalize(input('type name: '))
  if l:type_name == ''
    return
  endif

  let l:lines = getline(l:first_line, l:last_line)
  let l:i = 0
  let l:l = l:first_line
  while l:l <= l:last_line
    let l:raw = l:lines[l:i]
    let l:capital = s:capitalize(l:raw)
    call setline(l:l, "\t".l:type_name.l:capital.' = '.l:type_name.'("'.l:raw.'")')
    let l:i += 1
    let l:l += 1
  endwhile
endfunction

function! s:capitalize(v)
  return substitute(a:v, '\(^\|[^A-Za-z]\)\([a-z]\)', '\u\2', 'g')
endfunction

command! -range=0 GoStringer call GoStringer(<count>,<line1>,<line2>)
" }}}

" Function: Switch Branch {{{
function! s:checkout(line)
  " echom a:line
  let l:branch = get(split(a:line), 1, '')
  " echom l:branch
  exec 'Git checkout '.l:branch
endfunction

command! SwitchBranch call fzf#run({
    \ 'source': "git-branches --color --exclude-current",
    \ 'sink': function('<SID>checkout'),
    \ 'down': '30%'
    \ })
nnoremap <C-x><C-g><C-b> :<C-u>SwitchBranch<CR>
" }}}

" Configure Plugins {{{
let s:dir = g:xdg_data_home . '/vim-plug'
if !isdirectory(s:dir)
  call mkdir(s:dir, 'p')
endif
call plug#begin(s:dir)
  let g:formatterpath = ['/Users/yamada/.pyenv/shims']

  " {{{ prabirshrestha/vim-lsp
  Plug 'prabirshrestha/async.vim'
  Plug 'prabirshrestha/vim-lsp'
  Plug 'prabirshrestha/asyncomplete.vim'
  Plug 'prabirshrestha/asyncomplete-lsp.vim'
  let g:lsp_async_completion = 1
  let g:lsp_signs_enabled = 1           " enable signs
  let g:lsp_diagnostics_echo_cursor = 1 " enable echo under cursor when in normal mode
  " 何故か上手くFormat on Saveが動かないので、この処理はvim-goなどに任せる
  " augroup Lsp.format
  "   autocmd!
  "   autocmd BufWritePre <buffer> LspDocumentFormatSync
  " augroup END

  nmap <Leader>ld <Plug>(lsp-definition)
  nmap <Leader>lh <Plug>(lsp-hover)
  nmap <Leader>ln <Plug>(lsp-next-error)
  nmap <Leader>lp <Plug>(lsp-previous-error)
  nmap <Leader>lr <Plug>(lsp-rename)
  nmap <Leader>lf <Plug>(lsp-document-format)

  " nmap <Leader> <Plug>(lsp-references)
  " nmap <Leader> <Plug>(lsp-code-action)
  " nmap <Leader> <Plug>(lsp-declaration)
  " nmap <Leader> <Plug>(lsp-document-symbol)
  " nmap <Leader> <Plug>(lsp-document-diagnostics)
  " nmap <Leader> <Plug>(lsp-workspace-symbol)
  " nmap <Leader> <Plug>(lsp-implementation)
  " nmap <Leader> <Plug>(lsp-type-definition)
  " nmap <Leader> <Plug>(lsp-status)

  " for golang
  if executable('bingo')
    augroup Lsp.go
      autocmd!
      autocmd User lsp_setup call lsp#register_server({
          \ 'name': 'go-lang',
          \ 'cmd': {server_info->['bingo', '-mode', 'stdio', '-format-style', 'goimports']},
          \ 'whitelist': ['go'],
          \ })
      autocmd FileType go setlocal omnifunc=lsp#complete
    augroup END
  endif

  " for python
  if executable('pyls')
    augroup Lsp.python
      autocmd!
      " pip install python-language-server
      autocmd User lsp_setup call lsp#register_server({
          \ 'name': 'pyls',
          \ 'cmd': {server_info->['pyls']},
          \ 'whitelist': ['python'],
          \ })
      autocmd FileType python setlocal omnifunc=lsp#complete
    augroup END
  endif

  " for TypeScript (using tsuquyomi)
  " if executable('typescript-language-server')
  "   augroup Lsp.typescript
  "     autocmd!
  "     autocmd User lsp_setup call lsp#register_server({
  "         \ 'name': 'typescript-language-server',
  "         \ 'cmd': {server_info->[&shell, &shellcmdflag, 'typescript-language-server --stdio']},
  "         \ 'root_uri':{server_info->lsp#utils#path_to_uri(lsp#utils#find_nearest_parent_file_directory(lsp#utils#get_buffer_path(), 'tsconfig.json'))},
  "         \ 'whitelist': ['typescript'],
  "         \ })
  "   augroup END
  " endif

  " 'javascript': ['eslint'],
  " 'go': ['gometalinter', 'go build'],
  " 'vim': ['vint'],
  " 'yaml': ['yamllint'],
  " 'python': ['mypy', 'flake8']

  " let g:ale_linters = {
  "     \ 'javascript': ['eslint'],
  "     \ 'go': ['gometalinter', 'go build'],
  "     \ 'vim': ['vint'],
  "     \ 'yaml': ['yamllint'],
  "     \ 'python': ['mypy', 'flake8']
  " \ }
  " let g:ale_python_mypy_executable = 'pyenv'
  " let g:ale_python_mypy_options = 'exec mypy --ignore-missing-imports --strict'

  " let g:ale_python_flake8_executable = 'pyenv'
  " let g:ale_python_flake8_options = 'exec flake8 --ignore=E501'

  " let g:ale_python_black_executable = 'pyenv'
  " let g:ale_python_black_options = 'exec black'

  " let g:ale_go_gometalinter_options = '--config=' . $XDG_CONFIG_HOME . '/gometalinter/config.json'
  " let g:ale_fixers = {
  "     \ 'typescript': ['tslint'],
  "     \ 'javascript': ['eslint'],
  "     \ 'python': ['black']
  " \ }

  " " }}}
  " {{{ airblade/vim-gitgutter
  Plug 'airblade/vim-gitgutter'
  let g:gitgutter_map_keys = 0   " suppress mapping
  " }}}
  " {{{ Quramy/tsuquyomi
  Plug 'Quramy/tsuquyomi'
  augroup TsuquyomiCmd
    autocmd FileType typescript nmap <buffer> <leader>g <Plug>(TsuquyomiDefinition)
    autocmd FileType typescript nmap <buffer> <leader>d <Plug>(TsuquyomiDefinition)
  augroup END
  " }}}
  " {{{ honza/vim-snippets
  " Snippets are separated from the engine. Add this if you want them:
  Plug 'honza/vim-snippets'

  " Track the engine.
  Plug 'SirVer/ultisnips'

  " Trigger configuration. Do not use <tab> if you use https://github.com/Valloric/YouCompleteMe.
  let g:UltiSnipsExpandTrigger="<c-x>"
  let g:UltiSnipsJumpForwardTrigger="<c-b>"
  let g:UltiSnipsJumpBackwardTrigger="<c-z>"

  " If you want :UltiSnipsEdit to split your window.
  " let g:UltiSnipsEditSplit="vertical"
  " }}}
  " {{{ tpope/vim-fugitive
  Plug 'tpope/vim-fugitive'
  nnoremap <C-x><C-g><C-s> :<C-u>Gstatus<CR>
  function! FugitiveReDetect(cmd)
    unlet! b:git_dir
    call fugitive#detect(getcwd())
  endfunction

  augroup fugitive-ov
    autocmd BufNew * call FugitiveReDetect('BufNew')
    autocmd BufNewFile * call FugitiveReDetect('BufNewFile')
    autocmd BufRead * call FugitiveReDetect('BufRead')
    autocmd CmdwinEnter * call FugitiveReDetect('CmdwinWnter')
    silent! autocmd DirChanged * bufdo call FugitiveReDetect('DirChanged')
    autocmd VimEnter * call FugitiveReDetect('VimEnter')
  augroup END
  " }}}
  " {{{ thinca/vim-splash
  Plug 'thinca/vim-splash'
  let g:splash#path = $XDG_CONFIG_HOME . '/vim/splash.txt'
  " }}}
  " {{{ junegunn/fzf
  Plug '/usr/local/opt/fzf'
  Plug 'kyoh86/fzf.vim'
  nnoremap <C-x><C-f> :<C-u>Files<CR>
  nnoremap <C-x><C-w> :<C-u>Windows<CR>
  nnoremap <C-x><C-b> :<C-u>Buffers<CR>
  nnoremap <C-x><C-i> :<C-u>History<CR>
  " }}}
  " {{{ itchyny/lightline.vim
  Plug 'itchyny/lightline.vim'
  let g:lightline = {
    \   'colorscheme': 'momiji',
    \   'separator': {
    \     'left': "\ue0b0",
    \     'right': "\ue0b2"
    \   },
    \   'subseparator': {
    \     'left': "\ue0b1",
    \     'right': "\ue0b3"
    \   },
    \   'active': {
    \     'left': [
    \       [ 'mode', 'paste' ],
    \       [ 'gitbranch', 'relativepath', 'readonly', 'modified', 'terminalinfo', 'gitstatus' ]
    \     ],
    \     'right': [
    \       [ 'linter_ok', 'linter_errors', 'linter_warnings' ],
    \       [ 'fileformat', 'fileencoding', 'filetype', 'lineinfo', 'percent' ]
    \     ]
    \   },
    \   'inactive': {
    \     'left': [
    \       [ 'mode', 'paste' ],
    \       [ 'gitbranch', 'relativepath', 'readonly', 'modified' ]
    \     ],
    \     'right': [
    \       [ 'filetype' ]
    \     ]
    \   },
    \   'mode_map': {
    \     'n': 'NORM', 'i': 'INS', 'R': 'REPL', 'v': 'VIS', 'V': 'VLNE', "\<C-v>": 'VBLK',
    \     'c': 'COMM', 's': 'SLCT', 'S': 'SLNE', "\<C-s>": 'SBLK', 't': 'TERM'
    \   },
    \   'component_expand': {
    \     'linter_ok': 'LightlineAleOK',
    \     'linter_warnings': 'LightlineAleWarnings',
    \     'linter_errors': 'LightlineAleErrors',
    \     'gitstatus': 'LightlineGitStatus'
    \   },
    \   'component_type': {
    \     'linter_warnings': 'warning',
    \     'gitstatus': 'warning',
    \     'linter_errors': 'error',
    \   },
    \   'component_function': {
    \     'fileformat': 'LightlineFileFormat',
    \     'fileencoding': 'LightlineFileEncoding',
    \     'filetype': 'LightlineFileType',
    \     'terminalinfo': 'LightlineTerminalInfo',
    \     'readonly': 'LightlineReadonly', 
    \     'gitbranch': 'LightlineFugitive',
    \     'relativepath': 'LightlineRelativePath',
    \     'filename': 'LightlineFilename',
    \     'lineinfo': 'LightlineLineInfo',
    \     'modified': 'LightlineModified'
    \   },
    \ }
  function! LightlinePercent() abort
    return &buftype ==# 'terminal' ? '' : '%3p%%'
  endfunction

  "TODO: port lightline-ale to lightline-LSP
  "Plug 'maximbaz/lightline-ale'
  "function! LightlineAleOK() abort
  "  return &buftype ==# 'terminal' ? '' : lightline#ale#ok()
  "endfunction
  "function! LightlineAleWarnings() abort
  "  return &buftype ==# 'terminal' ? '' : lightline#ale#warnings()
  "endfunction
  "function! LightlineAleErrors() abort
  "  return &buftype ==# 'terminal' ? '' : lightline#ale#errors()
  "endfunction

  function! LightlineModified() abort
    return &buftype ==# 'terminal' ? '' : &modified ? '+' : &modifiable ? '' : '-'
  endfunction
  function! LightlineFileFormat() abort
    return &buftype ==# 'terminal' ? '' : &ff
  endfunction
  function! LightlineFileEncoding() abort
    return &buftype ==# 'terminal' ? '' : &fenc !=# '' ? &fenc : &enc
  endfunction
  function! LightlineFileType() abort
    return &buftype ==# 'terminal' ? '' : &ft !=# '' ? &ft : "no ft"
  endfunction
  function! LightlineLineInfo() abort
    return &buftype ==# 'terminal' ? '' : "\ue0a1".line('.').":".col('.')
  endfunction
  function! LightlineTerminalInfo() abort
    if &buftype !=# 'terminal'
      return ''
    endif
    let l:ttl=term_gettitle('%')
    let l:rel=fnamemodify(l:ttl, ':p:.')
    if l:rel ==# ""
      let l:rel=fnamemodify(l:ttl, ':t:.')
    elseif l:rel[0] != '/'
      let l:rel='./'.l:rel
    endif
    return bufnr('%').':'.l:rel
  endfunction
  function! LightlineRelativePath() abort
    return &buftype ==# 'terminal' ? '' : bufnr('%') . ':' . (expand('%') !=# '' ? expand('%') : '[No Name]')
  endfunction
  function! LightlineFilename() abort
    return &buftype ==# 'terminal' ? '' : bufnr('%') . ':' . (expand('%:t') !=# '' ? expand('%:t') : '[No Name]')
  endfunction
  function! LightlineReadonly() abort
    return &buftype ==# 'terminal' ? '' : &readonly ? "\ue0a2" : ''
  endfunction
  function! LightlineFugitive() abort
    if exists('*fugitive#head')
      let l:branch = fugitive#head()
      return l:branch !=# '' ? "\ue0a0 ".l:branch : ''
    endif
    return ''
  endfunction
  function! LightlineGitStatus()
    if &buftype !=# 'terminal'
      return ''
    endif
    let l:ttl=term_gettitle('%')
    let l:stat = s:getGitStatus(l:ttl)
    let l:commit = s:statPart(l:stat, 'ahead', '⬆ ') . s:statPart(l:stat, 'behind', '⬇ ')
    let l:merge = s:statPart(l:stat, 'unmerged', 'Unmerged:')
    let l:stage = s:statPart(l:stat, 'staged', '+') . s:statPart(l:stat, 'unstaged', '-')
    let l:warn = [ l:commit, l:merge, l:stage ]
    let l:brch = s:statPart(l:stat, 'local-branch', "\ue0a0 ")
    return [ [ l:brch ], l:warn, [] ]
  endfunction
  function! s:statPart(stat, key, pre)
    if !has_key(a:stat, a:key) || a:stat[a:key] ==# ''
      return ''
    endif
    return a:pre . a:stat[a:key]
  endfunction
  function! s:getGitStatus(path)
    let l:info = {}
    let l:res = system("git -C '" . a:path . "' status --porcelain --branch --untracked-files --ahead-behind --renames")
    if l:res[0:6] ==# 'fatal: '
      return l:info
    endif
    let [l:branch; l:files] = split(l:res, "\n")
    let [l:info['local-branch'], l:info['remote-branch']; l:remain] = split(l:branch, '\.\.\.\|[ \[\],]')[1:]
    let l:key = ''
    for l:_ in l:remain
      if l:key !=# ''
        let l:info[l:key] = l:_
        let l:key = ''
      else
        let l:key = l:_
      endif
    endfor
    for l:file in l:files
      if l:file[0] ==# 'U' || l:file[1] ==# 'U' || l:file[0:1] ==# 'AA' || l:file[0:1] ==# 'DD'
        call s:inc(l:info, 'unmerged')
      elseif l:file[0:1] ==# '??'
        call s:inc(l:info, 'untracked')
      else
        if l:file[0] !=# ' '
          call s:inc(l:info, 'staged')
        endif
        if l:file[1] !=# ' '
          call s:inc(l:info, 'unstaged')
        endif
      endif
    endfor
    return l:info
  endfunction
  function! s:inc(info, key)
    let a:info[a:key] = get(a:info, a:key, 0) + 1
  endfunction
  set laststatus=2  " statuslineは常に表示
  set noshowmode  " lightlineで表示するので、vim標準のモード表示は隠す
  " }}}
  " {{{ romainl/vim-qf
  Plug 'romainl/vim-qf'
  let g:qf_auto_quit = 0  " disable `quit Vim if the last window is a location/quickfix window`
  " }}}
  " {{{ plasticboy/vim-markdown
  Plug 'plasticboy/vim-markdown'
  let g:vim_markdown_folding_disabled = 1
  let g:vim_markdown_fenced_languages = ['c++=cpp', 'viml=vim', 'bash=sh', 'ini=dosini', 'uml=plantuml']
  let g:vim_markdown_math = 1
  let g:vim_markdown_frontmatter = 1
  let g:vim_markdown_toml_frontmatter = 1
  let g:vim_markdown_json_frontmatter = 1
  let g:vim_markdown_conceal = 0
  let g:tex_conceal = ''
  " }}}
   " {{{ jremmen/vim-ripgrep
  Plug 'jremmen/vim-ripgrep'
  let g:rg_command = 'rg --vimgrep'
  " }}}
  " {{{ fatih/vim-go
  Plug 'fatih/vim-go', { 'do': ':GoUpdateBinaries', 'for': 'go' }
  let g:go_highlight_functions = 1
  let g:go_highlight_string_spellcheck = 0
  let g:go_highlight_format_strings = 0

  " LSPに任せる機能をOFFにする
  let g:go_gocode_unimported_packages = 0
  let g:go_gocode_propose_source = 0
  let g:go_fmt_autosave = 1 "with vim-lsp TODO: vim-lspのformat on saveが使えるようになったら切る
  let g:go_fmt_command = "goimportssw"
  let g:go_gocode_propose_builtins = 0 "with vim-lsp
  let g:go_def_mapping_enabled = 0
  let g:go_doc_keywordprg_enabled = 0

  " }}}
  " {{{ davidhalter/jedi-vim
  Plug 'davidhalter/jedi-vim', {'for': 'python'} 
  let g:jedi#completions_enabled = 0 " deoplete.nvimに任せる
  let g:jedi#show_call_signatures = 1
  " }}}
  " {{{ lambdalisue/vim-pyenv
  Plug 'lambdalisue/vim-pyenv'
  function! s:jedi_auto_force_py_version() abort
    let g:jedi#force_py_version = pyenv#python#get_internal_major_version()
  endfunction
  augroup vim-pyenv-custom-augroup
    autocmd! *
    autocmd User vim-pyenv-activate-post   call s:jedi_auto_force_py_version()
    autocmd User vim-pyenv-deactivate-post call s:jedi_auto_force_py_version()
  augroup END
  " }}}
  " {{{ aklt/plantuml-syntax
  Plug 'aklt/plantuml-syntax'
  augroup PlantUMLCmd
    autocmd FileType plantuml command! OpenUml :!open -a "Google Chrome" %
  augroup END
  " }}}
  " {{{ elzr/vim-json
  Plug 'elzr/vim-json'
  let g:vim_json_syntax_conceal = 0
  " }}}
  " {{{ qpkorr/vim-bufkill
  Plug 'qpkorr/vim-bufkill'
  let g:BufKillCreateMappings = 0
  " }}}
  " {{{ kyoh86/vim-gogh
  Plug 'kyoh86/vim-gogh'
  " let g:gogh_params_list_primary = 1  TODO: wacul, wcl48 to modules
  nmap <C-x><C-g><C-p> <Plug>(gogh-switch-project)
  nmap <C-x><C-g><C-g> <Plug>(gogh-get-repository)
  " }}}
  Plug 'vim-scripts/sudo.vim'
  Plug 'stefandtw/quickfix-reflector.vim'
  Plug 'kyoh86/vim-wipeout'
  Plug 'sodapopcan/vim-twiggy'
  Plug 'Chiel92/vim-autoformat'
  Plug 'Glench/Vim-Jinja2-Syntax'
  Plug 'briancollins/vim-jst'
  Plug 'cespare/vim-toml', {'for': 'toml'}
  Plug 'editorconfig/editorconfig-vim'
  Plug 'idanarye/vim-merginal'
  Plug 'justinmk/vim-dirvish'
  Plug 'kana/vim-textobj-entire'
  Plug 'kana/vim-textobj-user'
  Plug 'kazuph/previm', { 'branch': 'feature/add-plantuml-plugin' }
  Plug 'kristijanhusak/vim-dirvish-git'
  Plug 'kyoh86/momiji', { 'rtp': 'vim' }
  Plug 'leafgarland/typescript-vim', { 'for': 'typescript' }
  Plug 'mdempsky/gocode', { 'rtp': 'vim', 'do': '~/.local/share/vim-plug/gocode/vim/symlink.sh' }
  Plug 'pangloss/vim-javascript', {'for': 'javascript'}
  Plug 'roosta/vim-srcery'
  Plug 'simeji/winresizer'
  Plug 'syngan/vim-vimlint'
  Plug 'tell-k/vim-autoflake'
  Plug 'tpope/vim-dispatch'
  Plug 'tpope/vim-rhubarb'  " fugitive.vim extension for GitHub
  Plug 'tpope/vim-surround'  " Edit surrounders (like brackets, parentheses and quotes)
  Plug 'tyru/capture.vim'  " Show Ex command output in a buffer
  Plug 'tyru/open-browser-github.vim'
  Plug 'tyru/open-browser.vim'
  Plug 'ynkdir/vim-vimlparser'
  Plug 'direnv/direnv.vim'
  Plug 'jez/vim-github-hub'
call plug#end()
" }}}

" Auto-install plugins {{{
let s:plug = {
      \ 'plugs': get(g:, 'plugs', {})
      \ }

function! s:plug.is_installed(name)
  return has_key(l:self.plugs, a:name) ? isdirectory(l:self.plugs[a:name].dir) : 0
endfunction

function! s:plug.check_installation()
  if empty(l:self.plugs)
    return
  endif
  let l:list = []
  for [l:name, l:spec] in items(l:self.plugs)
    if !isdirectory(l:spec.dir)
      call add(l:list, l:spec.uri)
    endif
  endfor
  if len(l:list) > 0
    let l:unplugged = map(l:list, 'substitute(v:val, "^.*github\.com/\\(.*/.*\\)\.git$", "\\1", "g")')
    " Ask whether installing plugs like NeoBundle
    echomsg 'Not installed plugs: ' . string(l:unplugged)
    if confirm('Install plugs now?', "yes\nNo", 2) == 1
      PlugInstall
      echo 'Pleaze restart vim'
    endif
  endif
endfunction

augroup CheckPlug
  autocmd!
  autocmd VimEnter * if !argc() | call s:plug.check_installation() | endif
augroup END
" }}}

" Colors {{{
syntax enable
set termguicolors
set background=dark
set hlsearch
colorscheme momiji
" }}}

" Indents {{{
set tabstop=2
set autoindent
set shiftwidth=2
set expandtab
set nowrap
" }}}

" Displays {{{
set number       " Show the line number
set emo          " Show emoji characters
set conceallevel=0
" }}}

" Show invisibles {{{
set list
set listchars=tab:»\ ,trail:∙,eol:↵,extends:»,precedes:«,nbsp:∙
" }}}

" Change cursor shape in different modes {{{
if exists('$TMUX')
  let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"
  let &t_SR = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=2\x7\<Esc>\\"
  let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
else
  let &t_SI = "\<Esc>]50;CursorShape=1\x7"
  let &t_SR = "\<Esc>]50;CursorShape=2\x7"
  let &t_EI = "\<Esc>]50;CursorShape=0\x7"
endif

let $NVIM_TUI_ENABLE_CURSOR_SHAPE=1
set guicursor=n-v-c:block-Cursor/lCursor-blinkon0,i-ci:ver25-Cursor/lCursor,r-cr:hor20-Cursor/lCursor
" }}}

" Completion {{{
set wildmode=longest:full,full
set completeopt=menu,menuone
let g:pymode_rope_complete_on_dot = 0
" }}}

" Terminal {{{
function! Tapi_ChangeDirectory(bufnum, arglist)
  if len(a:arglist) == 1
    exec 'cd ' . fnameescape(a:arglist[0])
  endif
endfunction

function! Tapi_UpdateStatus(bufnum, arglist)
  if len(a:arglist) == 1
    call lightline#update()
  endif
endfunction
" }}}

" Other misc settings {{{
set clipboard+=unnamedplus,unnamed
set hidden              " able to edit without saving
set fixendofline
set showcmd
set ambiwidth=double
set foldmethod=marker
set backspace=2  
set cursorline   " Highlight cursor line
set showtabline=1
highlight Pmenu ctermfg=159 ctermbg=17
" }}}

" Load settings for each location. {{{
augroup vimrc-local
  autocmd!
  autocmd BufNewFile,BufReadPost * call s:vimrc_local(expand('<afile>:p:h'))
augroup END

function! s:vimrc_local(loc)
  let l:files = findfile('.vimrc.local', escape(a:loc, ' ') . ';', -1)
  for l:i in reverse(filter(l:files, 'filereadable(v:val)'))
    source `=l:i`
  endfor
endfunction
" }}}
