" Setup encodings {{{
set encoding=utf-8
scriptencoding utf-8
" }}}

" Setup XDG_HOME {{{
set undodir=$XDG_CACHE_HOME/vim/undo
set directory=$XDG_CACHE_HOME/vim/swap
set backupdir=$XDG_CACHE_HOME/vim/backup
set viminfo+='1000,n$XDG_CACHE_HOME/vim/viminfo
set runtimepath=$XDG_CONFIG_HOME/vim,$VIMRUNTIME,$XDG_CONFIG_HOME/vim/after
" }}}

" Setup Environment Variables {{{
" ZSHとVIM両方に効かせる環境変数はここで設定する
" ZSHだけでいい場合は.zshenvで設定すればよい

" 基本環境設定:
let $LANG='ja_JP.UTF-8'
let $ARCHFLAGS='-arch x86_64'
let $EDITOR='vim'
let $COLORTERM='xterm-256color'
let $TERM='xterm-256color'
if ($XDG_CONFIG_HOME ==# '')
  let $XDG_CONFIG_HOME=$HOME.'/.config'
end

" Path環境変数の設定:
let $PATH='/usr/local/bin:'.$PATH
let $PATH='/usr/local/sbin:'.$PATH
let $PATH=$PATH.':/bin'
let $PATH=$PATH.':/usr/bin'
let $PATH=$PATH.':/sbin'
let $PATH=$PATH.':/usr/sbin'

" Zsh:
let $ZDOTDIR=$HOME.'/.config/zsh'

" Go:
let $GOPATH=$HOME.'/go'
let $PATH=$PATH.':/usr/local/go/bin:'.$HOME.'/go/bin'

" Generator-go-project:
let $GO_PROJECT_ROOT=$HOME.'/Projects'

" Python: (support sqlite3 and mysql library (used by mypy, etc...))
let $LDFLAGS="-L/usr/local/opt/zlib/lib -L/usr/local/opt/sqlite/lib"
let $CPPFLAGS="-I/usr/local/opt/zlib/include -I/usr/local/opt/sqlite/include"
let $LIBRARY_PATH=$LIBRARY_PATH.':/usr/local/opt/openssl/lib/'

" Python:
let $PYTHON_CONFIGURE_OPTS='--enable-framework'
let $PYENV_DEFAULT_PACKAGES=$XDG_CONFIG_HOME.'/pyenv/default-packages'
let $PYENV_ROOT=$HOME.'/.pyenv'
let $PATH=$PYENV_ROOT.'/bin:'.$PYENV_ROOT.'/shims:'.$PATH
let $PIP_REQUIRE_VIRTUALENV='true'

" Node:
let $PATH=$PATH.':'.$HOME.'/.nodenv/shims:'.$HOME.'/.nodenv/bin'

" GNU commands:
let $PATH='/usr/local/opt/gzip/bin:'.$PATH
let $PATH='/usr/local/opt/openssl/bin:'.$PATH

" FZF (https://github.com/junegunn/fzf):
let $FZF_DEFAULT_OPTS='--inline-info --no-mouse --extended --ansi --no-sort'
let $FZF_DEFAULT_COMMAND='rg --files --hidden --follow --maxdepth 10 --glob "!.git/*" --glob "!*.egg-info/*" --glob "!*/__pycache__/*" --glob "!.mypy_cache/*"'

" Scala:
let $SCALA_HOME='/usr/local/bin/scala'
let $PATH=$PATH.':'.$SCALA_HOME.'/bin'

" Yarn:
let $PATH=$PATH.':'.$HOME.'/.yarn/bin'

" Perl:
let $PATH=$PATH.':'.$HOME.'/perl5/bin'

" Gigamoji:
let $GIGAMOJI_BG=':space:'

" Fzf:
let $PATH=$PATH.':'.$HOME.'/.fzf/bin'

" dotfiles自体
let $DOTFILES=$HOME.'/.config'
let $DOTS=$DOTFILES

silent! ru ./secret.vim

" }}}

" Setup XDG Home directory paths. {{{
let g:xdg_config_home=$XDG_CONFIG_HOME
if g:xdg_config_home ==# ''
  let g:xdg_config_home = $HOME.'/.config'
endif

let g:xdg_data_home=$XDG_DATA_HOME
if g:xdg_data_home ==# ''
  let g:xdg_data_home = $HOME.'/.local/share'
endif

let s:cachedir=$XDG_CACHE_HOME
if s:cachedir ==# ''
  let s:cachedir = $HOME.'/.cache'
endif

let &directory = s:cachedir.'/vim/swap'
if !isdirectory(&directory)
  call mkdir(&directory, 'p')
endif
let &backupdir = s:cachedir.'/vim/backup'
if !isdirectory(&backupdir)
  call mkdir(&backupdir, 'p')
endif
" }}}

" Functions {{{
" Function: Edit Configurations {{{
let g:config_home = g:xdg_config_home . '/vim'
let g:vimrc_file = g:config_home . '/vimrc'
function! Config(bang)
  execute 'edit' . a:bang . ' ' . g:vimrc_file
endfunction
command! -bang -nargs=0 Config :call Config('<bang>')

if !exists('*ConfigReload')
  function! ConfigReload()
    " reload vimrc
    execute 'source ' . g:vimrc_file
  endfunction
endif
" }}}

" Function: Switch Branch {{{
function! s:git_switch(line)
  let l:branch = get(split(a:line), 1, '')
  exec '!git switch '.l:branch
endfunction

command! SwitchBranch call fzf#run({
    \ 'source': "git-branches --color --exclude-current",
    \ 'sink': function('<SID>git_switch'),
    \ 'down': '30%'
    \ })
nnoremap <Leader>gb :<C-u>SwitchBranch<CR>
" }}}

" Function: Update Terminal Window Title {{{
function! Tapi_UpdateStatus(bufnum, arglist)
  if len(a:arglist) == 1
    call lightline#update()
  endif
endfunction
" }}}
" }}}

" Configure Plugins {{{
function! _plug_begin()
  let l:dir = g:xdg_data_home . '/vim-plug'
  if !isdirectory(l:dir)
    call mkdir(l:dir, 'p')
  endif
  call plug#begin(l:dir)
endfunction

call _plug_begin()
  " {{{ prabirshrestha/vim-lsp
  Plug 'prabirshrestha/async.vim'
  Plug 'prabirshrestha/vim-lsp'

  Plug 'prabirshrestha/asyncomplete.vim'
  let g:asyncomplete_auto_completeopt = 1  " Set default `completeopt` options. These are `menuone,noinsert,noselect`
  inoremap <expr> <Tab>   pumvisible() ? "\<C-n>" : "\<Tab>"
  inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"
  inoremap <expr> <C-y> pumvisible() ? asyncomplete#close_popup() : "\<C-y>"
  inoremap <expr> <cr> pumvisible() ? asyncomplete#close_popup() : "\<cr>"
  Plug 'prabirshrestha/asyncomplete-lsp.vim'

  let g:lsp_async_completion = 1
  let g:lsp_signs_enabled = 1           " enable signs
  let g:lsp_diagnostics_echo_cursor = 1 " enable echo under cursor when in normal mode
  let g:lsp_highlight_references_enabled = 0 " disable references highlighting

  " 保存時に自動でフォーマット
  augroup Lsp.format
    autocmd!
    autocmd BufWritePre *.go,*.py silent LspDocumentFormatSync
  augroup END

  nmap <Leader>ld <Plug>(lsp-definition)
  nmap <Leader>lh <Plug>(lsp-hover)
  nmap <Leader>ln <Plug>(lsp-next-error)
  nmap <Leader>lp <Plug>(lsp-previous-error)
  nmap <Leader>lr <Plug>(lsp-rename)
  nmap <Leader>lf <Plug>(lsp-document-format)

  " nmap <Leader> <Plug>(lsp-references)
  " nmap <Leader> <Plug>(lsp-code-action)
  " nmap <Leader> <Plug>(lsp-declaration)
  " nmap <Leader> <Plug>(lsp-document-symbol)
  " nmap <Leader> <Plug>(lsp-document-diagnostics)
  " nmap <Leader> <Plug>(lsp-workspace-symbol)
  " nmap <Leader> <Plug>(lsp-implementation)
  " nmap <Leader> <Plug>(lsp-type-definition)
  nmap <Leader>ls <Plug>(lsp-status)

  " for golang
  augroup Lsp.go
    autocmd!

    if executable('gopls')
      autocmd User lsp_setup call lsp#register_server({
          \ 'name': 'go-lang',
          \ 'cmd': {server_info->['gopls']},
          \ 'whitelist': ['go'],
          \ 'workspace_config': {'gopls': {
          \    'source.organizeImports': 'true',
          \ }},
          \ })
      autocmd FileType go setlocal omnifunc=lsp#complete
      autocmd BufWritePre *.go LspDocumentFormatSync
    else
      echoerr 'gopls not found'
    endif
    " if executable('go-langserver')
    "   au User lsp_setup call lsp#register_server({
    "     \ 'name': 'go-langserver',
    "     \ 'cmd': {server_info->['go-langserver', '-gocodecompletion']},
    "     \ 'whitelist': ['go'],
    "     \ })
    "   autocmd FileType go setlocal omnifunc=lsp#complete
    "   autocmd BufWritePre *.go LspDocumentFormatSync
    " else
    "   echoerr 'go-langserver not found'
    " endif
  augroup END

  " for some linters
  augroup Lsp.lint
    autocmd!

    if executable('efm-langserver')
      autocmd User lsp_setup call lsp#register_server({
          \ 'name': 'efm-langserver',
          \ 'cmd': {server_info->['efm-langserver']},
          \ 'whitelist': ['go', 'vim', 'markdown', 'sh'],
          \ })
    else
      echoerr 'efm-langserver not found'
    endif
  augroup END

  " for python
  augroup Lsp.python
    autocmd!

    if executable('pyls')
      " pip install python-language-server
      autocmd User lsp_setup call lsp#register_server({
          \ 'name': 'pyls',
          \ 'cmd': {server_info->['pyls']},
          \ 'workspace_config': {'pyls': {
          \   'configurationSources': ['flake8'],
          \   'plugins': {
          \     'black': {'enabled': v:true},
          \     'pycodestyle': {'enabled': v:false},
          \   },
          \ }},
          \ 'whitelist': ['python'],
          \ })
      autocmd FileType python setlocal omnifunc=lsp#complete
      autocmd BufWinEnter *.py :call lsp#enable()
    else
      echoerr 'pyls not found'
    endif
  augroup END

  " for viml
  augroup Lsp.viml
    autocmd!
    if executable('vim-language-server')
      autocmd User lsp_setup call lsp#register_server({
          \ 'name': 'vim-language-server',
          \ 'cmd': {server_info->[&shell, &shellcmdflag, 'vim-language-server --stdio']},
          \ 'whitelist': ['vim'],
          \ 'workspace_config': {
          \   "iskeyword": "vim iskeyword option",
          \   "vimruntime": $VIMRUNTIME,
          \   "runtimepath": $VIM,
          \   "diagnostic": {
          \     "enable": v:true
          \   }
          \ },
          \ })
    else
      echoerr 'vim-language-server is not found'
    endif
  augroup END

  " for TypeScript (using tsuquyomi)
  augroup Lsp.typescript
    autocmd!
    if executable('typescript-language-server')
      autocmd User lsp_setup call lsp#register_server({
          \ 'name': 'typescript-language-server',
          \ 'cmd': {server_info->[&shell, &shellcmdflag, 'typescript-language-server --stdio']},
          \ 'root_uri':{server_info->lsp#utils#path_to_uri(lsp#utils#find_nearest_parent_file_directory(lsp#utils#get_buffer_path(), 'tsconfig.json'))},
          \ 'whitelist': ['typescript'],
          \ })
    else
      echoerr 'typescript-language-server not found'
    endif
  augroup END

  " }}}
  " {{{ airblade/vim-gitgutter
  Plug 'airblade/vim-gitgutter'
  " }}}
  " {{{ itchyny/lightline.vim
  Plug 'itchyny/lightline.vim'
  let g:lightline = {
    \   'colorscheme': 'momiji',
    \   'separator': {
    \     'left': "\ue0c6",
    \     'right': "\ue0c7"
    \   },
    \   'subseparator': {
    \     'left': "\ue0b5",
    \     'right': "\ue0b7"
    \   },
    \   'active': {
    \     'left': [
    \       [ 'mode', 'paste' ],
    \       [ 'pwd', 'gitstatus', 'relativepath', 'readonly', 'modified', 'terminalinfo' ]
    \     ],
    \     'right': [
    \       [ 'linter_ok', 'linter_errors', 'linter_warnings' ],
    \       [ 'fileformat', 'fileencoding', 'filetype', 'lineinfo' ]
    \     ]
    \   },
    \   'inactive': {
    \     'left': [
    \       [ 'mode', 'paste' ],
    \       [ 'relativepath', 'readonly', 'modified' ]
    \     ],
    \     'right': [
    \       [ 'filetype' ]
    \     ]
    \   },
    \   'mode_map': {
    \     'n': 'NORM', 'i': 'INS', 'R': 'REPL', 'v': 'VIS', 'V': 'VLNE', "\<C-v>": 'VBLK',
    \     'c': 'COMM', 's': 'SLCT', 'S': 'SLNE', "\<C-s>": 'SBLK', 't': 'TERM'
    \   },
    \   'component_expand': {
    \     'linter_ok': 'LightlineLspOK',
    \     'linter_warnings': 'LightlineLspWarnings',
    \     'linter_errors': 'LightlineLspErrors',
    \     'gitstatus': 'LightlineGitStatus'
    \   },
    \   'component_type': {
    \     'linter_warnings': 'warning',
    \     'gitstatus': 'warning',
    \     'linter_errors': 'error',
    \   },
    \   'component_function': {
    \     'pwd': 'LightlinePwd',
    \     'percent': 'LightlinePercent',
    \     'fileformat': 'LightlineDevFileformat',
    \     'fileencoding': 'LightlineFileEncoding',
    \     'filetype': 'LightlineDevFiletype',
    \     'terminalinfo': 'LightlineTerminalInfo',
    \     'readonly': 'LightlineReadonly', 
    \     'relativepath': 'LightlineRelativePath',
    \     'filename': 'LightlineFilename',
    \     'gitgutter': 'LightlineGitGutter',
    \     'lineinfo': 'LightlineLineInfo',
    \     'modified': 'LightlineModified'
    \   },
    \ }
  augroup LightLineUpdate
    autocmd!
    autocmd DirChanged * call lightline#update()
  augroup END
  function! LightlinePwd() abort
    return fnamemodify(getcwd(), ':t')
  endfunction
  function! LightlinePercent() abort
    let l:last = line('$')
    let l:cur = line('.')
    return &buftype ==# 'terminal' ? '' : printf('%3d%% of %d', l:cur * 100 / l:last, l:last)
  endfunction
  function! LightlineDevFiletype()
    return &buftype ==# 'terminal' ? '' : strlen(&filetype) ? &filetype . ' ' . WebDevIconsGetFileTypeSymbol() : 'no ft'
  endfunction

  function! LightlineDevFileformat()
    return &buftype ==# 'terminal' ? '' : (&fileformat ==# 'unix' ? '' : &fileformat . ' ' . WebDevIconsGetFileFormatSymbol())
  endfunction

  function! LightlineModified() abort
    return &buftype ==# 'terminal' ? '' : &modified ? '+' : &modifiable ? '' : '-'
  endfunction
  function! LightlineFileEncoding() abort
    let l:enc = &fileencoding !=# '' ? &fileencoding : &encoding
    return &buftype ==# 'terminal' ? '' : (l:enc ==# 'utf-8' ? '' : l:enc)
  endfunction
  function! LightlineLineInfo() abort
    return &buftype ==# 'terminal' ? '' : "\ue0a1".line('.').':'.printf('%03d', col('.'))
  endfunction
  function! LightlineTerminalInfo() abort
    if &buftype !=# 'terminal'
      return ''
    endif
    let l:ttl=term_gettitle('%')
    let l:rel=fnamemodify(l:ttl, ':p:.')
    if l:rel ==# ''
      let l:rel='.'
    elseif l:rel[0] !=# '/'
      let l:rel='./'.l:rel
    endif
    return bufnr('%').':'.l:rel
  endfunction
  function! LightlineRelativePath() abort
    if expand('%') ==# ''
      let l:name = '[No Name]'
    else
      let l:max = winwidth(0) - 100
      let l:name = expand('%:t')
      if len(l:name) < l:max
        let l:name = expand('%:.')
        if l:name ==# ''
          let l:name = '.'
        elseif l:name[0] !=# '/'
          let l:name='./'.l:name
        endif

        if len(l:name) > l:max
          let l:name = '…' . l:name[-l:max :]
        endif
      endif
    endif

    return &buftype ==# 'terminal' ? '' : bufnr('%') . ':' . l:name
  endfunction
  function! LightlineFilename() abort
    return &buftype ==# 'terminal' ? '' : bufnr('%') . ':' . (expand('%:t') !=# '' ? expand('%:t') : '[No Name]')
  endfunction
  function! LightlineReadonly() abort
    return &buftype ==# 'terminal' ? '' : &readonly ? "\ue0a2" : ''
  endfunction
  function! LightlineGitStatus()
    let l:brch = ''
    let l:warn = ''
    let l:location = getcwd()
    if &buftype ==# 'terminal'
      let l:location = term_gettitle('%')
    endif

    let l:stat = s:getGitStatus(l:location)
    let l:commit = s:statPart(l:stat, 'ahead', '⬆ ') . s:statPart(l:stat, 'behind', '⬇ ')
    let l:merge = s:statPart(l:stat, 'unmerged', 'Unmerged:')
    let l:stage = s:statPart(l:stat, 'staged', '+') . s:statPart(l:stat, 'unstaged', '-')
    let l:warn = [ l:commit, l:merge, l:stage ]
    let l:brch = s:statPart(l:stat, 'local-branch', "\ue0a0 ")
    return [ [ l:brch ], l:warn, [] ]
  endfunction

  function! LightlineGitGutter()
    if ! exists('*GitGutterGetHunkSummary')
          \ || ! get(g:, 'gitgutter_enabled', 0)
          \ || winwidth('.') <= 90
      return ''
    endif
    let l:symbols = [
          \ g:gitgutter_sign_added . ' ',
          \ g:gitgutter_sign_modified . ' ',
          \ g:gitgutter_sign_removed . ' '
          \ ]
    let l:hunks = GitGutterGetHunkSummary()
    let l:ret = []
    for i in [0, 1, 2]
      if l:hunks[i] > 0
        call add(l:ret, l:symbols[i] . l:hunks[i])
      endif
    endfor
    return join(l:ret, ' ')
  endfunction

  function! s:statPart(stat, key, pre)
    if !has_key(a:stat, a:key) || a:stat[a:key] ==# ''
      return ''
    endif
    return a:pre . a:stat[a:key]
  endfunction
  function! s:getGitStatus(path)
    let l:info = {}
    let l:res = system("git -C '" . a:path . "' status --porcelain --branch --untracked-files --ahead-behind --renames")
    if l:res[0:6] ==# 'fatal: '
      return l:info
    endif
    for l:file in split(l:res, "\n")
      if l:file[0:1] ==# '##'
        " ブランチ名を取得する
        let [l:info['local-branch'], l:info['remote-branch']; l:remain] = split(l:file, '\.\.\.\|[ \[\],]')[1:]
        let l:key = ''
        for l:_ in l:remain
          if l:key !=# ''
            let l:info[l:key] = l:_
            let l:key = ''
          else
            let l:key = l:_
          endif
        endfor
      elseif l:file[0] ==# 'U' || l:file[1] ==# 'U' || l:file[0:1] ==# 'AA' || l:file[0:1] ==# 'DD'
        call s:inc(l:info, 'unmerged')
      elseif l:file[0:1] ==# '??'
        call s:inc(l:info, 'untracked')
      else
        if l:file[0] !=# ' '
          call s:inc(l:info, 'staged')
        endif
        if l:file[1] !=# ' '
          call s:inc(l:info, 'unstaged')
        endif
      endif
    endfor
    return l:info
  endfunction
  function! s:inc(info, key)
    let a:info[a:key] = get(a:info, a:key, 0) + 1
  endfunction
  set laststatus=2  " statuslineは常に表示
  set noshowmode  " lightlineで表示するので、vim標準のモード表示は隠す
  function! LightlineLspOK() abort
    if &buftype ==# 'terminal'
      return ''
    endif
    let l:counts = lsp#get_buffer_diagnostics_counts()    " *vim-lsp-get_buffer_diagnostics_counts*
    if l:counts['error'] == 0 && l:counts['warning'] == 0
      return 'OK'
    endif
    return ''
  endfunction
  function! LightlineLspWarnings() abort
    if &buftype ==# 'terminal'
      return ''
    endif
    let l:counts = lsp#get_buffer_diagnostics_counts()    " *vim-lsp-get_buffer_diagnostics_counts*
    if l:counts['warning'] == 0
      return ''
    endif
    return 'W:' . l:counts['warning']
  endfunction
  function! LightlineLspErrors() abort
    if &buftype ==# 'terminal'
      return ''
    endif
    let l:counts = lsp#get_buffer_diagnostics_counts()    " *vim-lsp-get_buffer_diagnostics_counts*
    if l:counts['error'] == 0
      return ''
    endif
    return 'E:' . l:counts['error']
  endfunction
  " }}}
  " {{{ plasticboy/vim-markdown
  Plug 'plasticboy/vim-markdown', {'for': 'markdown'}
  let g:vim_markdown_folding_disabled = 1
  let g:vim_markdown_fenced_languages = ['c++=cpp', 'viml=vim', 'bash=sh', 'ini=dosini', 'uml=plantuml']
  let g:vim_markdown_math = 1
  let g:vim_markdown_frontmatter = 1
  let g:vim_markdown_toml_frontmatter = 1
  let g:vim_markdown_json_frontmatter = 1
  let g:vim_markdown_conceal = 0
  let g:tex_conceal = ''
  " }}}
   " {{{ jremmen/vim-ripgrep
  Plug 'jremmen/vim-ripgrep', {'on': ['Rg', 'RgRoot']}
  let g:rg_command = 'rg --vimgrep'
  " }}}
  " {{{ lambdalisue/vim-pyenv
  Plug 'lambdalisue/vim-pyenv', {'for': 'python'}
  Plug 'jmcantrell/vim-virtualenv', {'for': 'python'}
  function! s:jedi_auto_force_py_version() abort
    let g:jedi#force_py_version = pyenv#python#get_internal_major_version()
  endfunction
  augroup vim-pyenv-custom-augroup
    autocmd! *
    autocmd User vim-pyenv-activate-post   call s:jedi_auto_force_py_version()
    autocmd User vim-pyenv-deactivate-post call s:jedi_auto_force_py_version()
  augroup END
  " }}}
  " {{{ aklt/plantuml-syntax
  Plug 'aklt/plantuml-syntax', {'for': 'plantuml'}
  augroup PlantUMLCmd
    autocmd FileType plantuml command! OpenUml :!open -a "Google Chrome" %
  augroup END
  " }}}
  " {{{ elzr/vim-json
  Plug 'elzr/vim-json', {'for': 'json'}
  let g:vim_json_syntax_conceal = 0
  " }}}
  " {{{ qpkorr/vim-bufkill
  Plug 'qpkorr/vim-bufkill'
  let g:BufKillCreateMappings = 0
  " }}}
  " {{{ arp242/gopher.vim
  Plug 'arp242/gopher.vim'
  " }}}
  " {{{ thinca/vim-quickrun
  Plug 'thinca/vim-quickrun', {'on': 'QuickRun'}
  let g:quickrun_config = {
        \ '_': {
        \   'runner': 'terminal'
        \   }
        \ }
  " }}}
  " {{{ osyo-manga/vim-operator-jump_side
  Plug 'osyo-manga/vim-operator-jump_side'
  " textobj の先頭へ移動する
  nmap <Leader>h <Plug>(operator-jump-head)
  " textobj の末尾へ移動する
  nmap <Leader>l <Plug>(operator-jump-tail)
  " }}}
  "{{{ 'simeji/winresizer'
  let g:winresizer_start_key = '<C-W><C-E>'
  Plug 'simeji/winresizer'
  "}}}
  "{{{'machakann/vim-sandwich'
  Plug 'machakann/vim-sandwich'  " Edit surrounders (like brackets, parentheses and quotes)
  nnoremap s <Nop>   " ignore s instead of the cl
  xnoremap s <Nop>   " ignore s instead of the cl
  silent! nmap <unique><silent> sc <Plug>(operator-sandwich-replace)<Plug>(operator-sandwich-release-count)<Plug>(textobj-sandwich-query-a)
  silent! nmap <unique><silent> scb <Plug>(operator-sandwich-replace)<Plug>(operator-sandwich-release-count)<Plug>(textobj-sandwich-auto-a)
  "}}}
  " Plug 'AndrewRadev/quickpeek.vim'
  Plug 'AndrewRadev/linediff.vim'
  Plug 'Glench/Vim-Jinja2-Syntax', {'for': 'jinja'}
  Plug 'bps/vim-textobj-python'
  Plug 'briancollins/vim-jst', {'for': 'jst'}
  Plug 'cespare/vim-toml', {'for': 'toml'}

if executable('direnv')
  Plug 'direnv/direnv.vim'
endif
  Plug 'iberianpig/tig-explorer.vim'
  Plug 'jez/vim-github-hub', {'for': 'ghhub'}
  Plug 'justinmk/vim-dirvish'
  Plug 'kana/vim-metarw'
  Plug 'kana/vim-operator-user'
  Plug 'kana/vim-textobj-entire'
  Plug 'kana/vim-textobj-user'
  Plug 'kazuph/previm', { 'branch': 'feature/add-plantuml-plugin' }
  Plug 'kristijanhusak/vim-dirvish-git'
  Plug 'leafgarland/typescript-vim', { 'for': 'typescript' }
  Plug 'machakann/vim-swap'
  Plug 'pangloss/vim-javascript', {'for': 'javascript'}
  Plug 'posva/vim-vue'
  Plug 'robertbasic/vim-hugo-helper'
  Plug 'ryanoasis/vim-devicons'
  Plug 'sgur/vim-textobj-parameter'
  Plug 'stefandtw/quickfix-reflector.vim', {'for': 'qf'}
  Plug 'tell-k/vim-autoflake', {'for': 'python'}
  Plug 'tpope/vim-dispatch'
  Plug 'tyru/capture.vim', {'on': 'Capture'}  " Show Ex command output in a buffer
  Plug 'tyru/open-browser-github.vim'
  Plug 'tyru/open-browser.vim'
  Plug 'vim-jp/vim-vimlparser'
  Plug 'vim-jp/vimdoc-ja'
  Plug 'vim-jp/vital.vim', {'on': 'Vitalize'}
  Plug 'vim-scripts/sudo.vim'

  " My Plugins {{{
  " {{{ kyoh86/vim-gogh
  Plug 'kyoh86/vim-gogh', {'dir': $GO_PROJECT_ROOT.'/github.com/kyoh86/vim-gogh'}
  " let g:gogh_params_list_primary = 1  TODO: wacul, wcl48 to modules
  let g:gogh_edit_project_command = 'vnew'
  nmap <Leader>ge <Plug>(gogh-edit-project)
  nmap <Leader>gp <Plug>(gogh-switch-project)
  nmap <Leader>gg <Plug>(gogh-get-repository)
  " }}}
  " {{{ kyoh86/vim-docbase
  Plug 'kyoh86/vim-docbase', {'dir': $GO_PROJECT_ROOT.'/github.com/kyoh86/vim-docbase'}
  let g:docbase_domain = 'wacul'
  " }}}
  " {{{ junegunn/fzf
  Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
  Plug 'kyoh86/fzf.vim', {'dir': $GO_PROJECT_ROOT.'/github.com/kyoh86/fzf.vim'}
  let g:fzf_command_prefix = 'Fzf'
  nnoremap <Leader>f  :<C-u>FzfFiles<CR>
  nnoremap <Leader>w  :<C-u>FzfWindows<CR>
  nnoremap <Leader>bb :<C-u>FzfBuffers<CR>
  nnoremap <Leader>bw :<C-u>FzfWipeouts<CR>
  nnoremap <Leader>i  :<C-u>FzfHistory<CR>
  nnoremap q:         :<C-u>FzfHistory :<CR>
  nnoremap q/         :<C-u>FzfHistory /<CR>
  " }}}
  Plug 'kyoh86/vim-wipeout', {'on': 'Wipeout', 'dir': $GO_PROJECT_ROOT.'/github.com/kyoh86/vim-wipeout'}
  Plug 'kyoh86/vim-editerm', {'dir': $GO_PROJECT_ROOT.'/github.com/kyoh86/vim-editerm'}
  Plug 'kyoh86/momiji', {'rtp': 'vim', 'dir': $GO_PROJECT_ROOT.'/github.com/kyoh86/momiji'}
  " }}}
call plug#end()

" Auto-install plugins {{{
let s:plug = {
      \ 'plugs': get(g:, 'plugs', {})
      \ }

function! s:plug.is_installed(name)
  return has_key(l:self.plugs, a:name) ? isdirectory(l:self.plugs[a:name].dir) : 0
endfunction

function! s:plug.check_installation()
  if empty(l:self.plugs)
    return
  endif
  let l:list = []
  for [l:name, l:spec] in items(l:self.plugs)
    if !isdirectory(l:spec.dir)
      if has_key(l:spec, 'uri')
        call add(l:list, l:spec.uri)
      endif
    endif
  endfor
  if len(l:list) > 0
    let l:unplugged = map(l:list, 'substitute(v:val, "^.*github\.com/\\(.*/.*\\)\.git$", "\\1", "g")')
    " Ask whether installing plugs like NeoBundle
    echomsg 'Not installed plugs: ' . string(l:unplugged)
    if confirm('Install plugs now?', "yes\nNo", 2) == 1
      PlugInstall
      echo 'Pleaze restart vim'
    endif
  endif
endfunction

augroup CheckPlug
  autocmd!
  autocmd VimEnter * if !argc() | call s:plug.check_installation() | endif
augroup END
" }}}

" }}}

" Settings {{{
" Colors {{{
syntax enable
set termguicolors
set background=dark
colorscheme momiji
" }}}

" Indents {{{
set tabstop=2
set autoindent
set shiftwidth=2
set expandtab
set nowrap
" }}}

" Displays {{{
set number       " Show the line number
set emoji        " Show emoji characters
set conceallevel=0
" }}}

" Show invisibles {{{
set list
set listchars=tab:»\ ,trail:∙,eol:↵,extends:»,precedes:«,nbsp:∙
" }}}

" Change cursor shape in different modes {{{
let &t_SI = "\<Esc>]50;CursorShape=1\x7"
let &t_SR = "\<Esc>]50;CursorShape=2\x7"
let &t_EI = "\<Esc>]50;CursorShape=0\x7"

" let $NVIM_TUI_ENABLE_CURSOR_SHAPE=1
" set guicursor=n-v-c:block-Cursor/lCursor-blinkon0,i-ci:ver25-Cursor/lCursor,r-cr:hor20-Cursor/lCursor
" }}}

" Completion {{{
set wildmenu
set wildmode=longest:full,full
" set completeopt=menuone,preview,noinsert,noselect  " set by asyncomplete.vim
" }}}

" Other misc settings {{{
set clipboard=unnamedplus,unnamed
set hidden              " able to edit without saving
set fixendofline        " <EOL> at the end of file will be restored if missing
set showcmd             " 
set textwidth=0         " never limit length of each line
set ambiwidth=double
set foldmethod=marker
set backspace=2
set cursorline   " Highlight cursor line
set showtabline=1
set hlsearch
set incsearch
highlight Pmenu ctermfg=159 ctermbg=17
" }}}

" Setup Keymaps (for regular functions) {{{
" Delete search highlight
nnoremap <ESC><ESC> :<C-u>nohl<CR><ESC>

" Quickfix
nnoremap <Leader>q :<C-u>copen<CR><ESC>

nnoremap Q <Nop>
augroup TermMap
  " ターミナルで
  "   * <C-\><C-n> による job <- -> normal モードの往復を可能にする
  "   * q によるmacro記録を禁止する
  autocmd! TerminalOpen *
      \ nnoremap <buffer> <C-\><C-n> i|
      \ nnoremap <buffer> q <Nop>|
augroup END

nnoremap <silent> tt :<C-u>terminal++curwin <CR>
nnoremap <silent> tx :<C-u>terminal         <CR>
nnoremap <silent> tv :<C-u>vertical terminal<CR>

" }}}

" Setup terminal {{{
if executable('/usr/local/bin/zsh')
  set shell=/usr/local/bin/zsh
elseif executable('/usr/bin/zsh')
  set shell=/usr/bin/zsh
endif

augroup TermSetting
  " ターミナルで
  "   * 行番号を表示しない
  "   * wrapする（と、なぜかWrapしなくなる）
  autocmd! TerminalOpen *
      \ setlocal nonumber wrap
augroup END
" }}}

" Default Plugins {{{
let g:is_posix = 1
let g:vim_json_conceal = 0
" }}}

" }}}

" GVim Settings {{{
set columns=200
set lines=50
set guioptions=cei
set guifont=Cica\ 11
" }}}
